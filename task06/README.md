# Общее
Это домашнее задание состоит из трёх задач, в которых вы будете реализовывать
дополнительную функциональность для языка ЯТЬ при помощи шаблона "Посетитель".

Первая задача оценивается в 0 (ноль) баллов и даже её решение не засчитывает тему.
Её корректность требуется для корректности оставшихся задач,
а стиль - для стиля оставшихся задач.

Вторая и третья задачи оцениваются независимо друг от друга в 2.5 балла каждая.
По каждой задаче 50% вы получаете за корректность и ещё 50% за стиль кода.

Задачу 1 требуется реализовывать на базе имеющихся файлов `model.py` и `test_model.py`.
Вы также можете использовать свои решения домашнего задания №4 (если зачтена корректность).
Для этого отдельным и первым коммитом преобразуйте имеющиеся файлы в ваш код.

Задачи 2 и 3 требуется реализовать в отдельных файлах.

# Задача 1: Visitor
Требуется добавить в класс `ASTNode` методы, необходимые согласно шаблону "Посетитель",
а также создать абстрактный базовый класс `ASTNodeVisitor`, содержащий нужные для
работы с AST методы.

## Подробнее
* Вы можете посмотреть на следующие задания, чтобы понять предполагаемые сценарии использования.
  * В частности, все реализации базового класса `ASTNodeVisitor` будут добавлены в следующих заданиях,
    не надо добавлять их в этом.
* `ASTNodeVisitor` должен являться ABC в терминологии Python (как `ASTNode`).
* Названия методов шаблона "Посетитель" должны соответствовать общепринятым.
* Настоятельно рекомендуется не решать это задачу отдельно от остальных двух: она не даёт баллов
  и следующие две задачи сильно завязаны на её решение.

## Тесты
В этом задании автоматическе тесты не требуются.

## Требования к корректности решения
Если присланные файлы не соответствуют хотя бы одному из условий ниже, решение считается некорректным и оценивается в 0 баллов:

* Должны отсутствовать синтаксические ошибки для Python 3
* `pycodestyle` при запуске без флагов не должен выдавать ошибок и предупреждений
* Все ваши автоматические тесты должны проходить
* Решение этой задачи должно быть в отдельном коммите

# Задача 2: Форматирование кода
В отдельном файле `printer.py` требуется реализовать класс `PrettyPrinter`,
наследующийся от `ASTNodeVisitor` из предыдущей задачи.
Также в этом файле требуется реализовать функцию `pretty_print(program)`,
которая использует `PrettyPrinter`.

В результате вызова `pretty_print` в стандартный поток вывода должна
выводиться программа на языке ЯТЬ, представленная абстрактным синтаксическим
деревом `program` (объект какого-либо класса из домашнего задания №4).
Точный синтаксис описан ниже.

## Пример
Следующий код:
```
TODO
```
может вывести такой текст:
```
TODO
```

## Подробнее
Вся программа в языке ЯТЬ состоит из последовательности команд (statements).
На вход методу `pretty_print` подается ровно одна команда языка ЯТЬ.
После каждой команды языка (и только после них) нужно выводит символ `;`.
Ниже описано, из чего может состоять команда языка.
Обратите внимание, что одна и та же конструкция может в одном контексте являться командой языке, а в другом — нет, будьте внимательны.

Команда — это одно из следующего списка:
* Арифметическое выражение
* Условное выражение (представляется как объект `Conditional`)
* Определение функции (представляется как объект `FunctionDefinition`)
* Конструкция print (представляется как объект `Print`)
* Конструкция read (представляется как объект `Read`)

Арифметическое выражение — это одно из следующего списка:
* Число (представляется как объект `Number`)
* Имя (представляется как объект `Reference`)
* Бинарная операция (представляется как `BinaryOperation`), аргументами которой являются арифметические выражения
* Унарная операция (представляется как `UnaryOperation`), аргументом которой является арифметические выражение
* Вызов функции (представляется как `FunctionCall`)

Таким образом, если известно, что нужно вывести для каждого из использованных в описании выше классов
(`Conditional`, `FunctionDefinition`, `Print`, `Read`, `Number`, `Reference`, `BinaryOperation`, `UnaryOperation` и `FunctionCall`),
то синтаксис языка будет полностью задан. Пройдемся по всему списку.

### `Conditional`
Для объекта `Conditional` необходимо вывести текст следующего вида:
```
if (<condition>) {
    <if true 0>
    <if true 1>
    …
    <if true k>
} else {
    <if false 0>
    <if false 1>
    …
    <if false n>
}
```
где:
* `<condition>` — арифметическое выражение, переданное как параметр condition конструктору Conditional
* `<if true 0>`, ... `<if true k>` — команды языка (т. е. после них нужно выводить ‘;’), которые переданы как список `if_true` в конструктор Conditional.
  Учтите, что список `if_true` может быть пустым или `None`, в этом случае нужно вывести просто фигурные скобки на отдельных строчках
* `<if false 0>`, ... `<if false n>` предложения языка (т. е. после них нужно выводить ‘;’), которые переданы как список if_false в конструктор Conditional.
  Учтите, что список `if_false` может быть пустым или `None`, в этом случае вы должны полностью опустить else часть

Например, следующий код:
```
pretty_print(Conditional(Number(42), [], []))
```
должен вывести такой текст:
```
if (42) {
};
```

### `FunctionDefinition`
Для объекта класса `FunctionDefinition` необходимо вывести текст следующего вида:
```
def <name>(arg0, arg1, …, argk) {
    <statement 0>;
    <statement 1>;
    …
    <statement n>;
}
```
где:
* `<name>` — имя функции, переданное как параметр `name` в конструктор `FunctionDefinition`
* `arg0`, `arg1`, ..., `argk` — имена формальных параметров, разделенные запятыми (лишних запятых быть не должно), переданные как список `args ` в конструктор Function,
   которая, в свою очередь, передана как параметр `function` в конструктор `FunctionDefinition`
   Учтите, что список формальных параметров может быть пустым, в этом случае нужно вывести просто круглые скобки.
   Гарантируется, что все `FunctionDefinition` в качестве `function` принимают `Function`, а отдельные `Function` в теле программы не встречаются.
* `<statement 0>`, ..., `<statement n>` — команды языка (т. е. они должны заканчиваться символом `;`),
   которые образуют тело функции (параметр `body` в конструкторе `Function`).
   Учтите, что тело функции может быть пустым, в этом случае нужно вывести просто фигурные скобки.

Например, следующий код:
```
pretty_print(FunctionDefinition("foo", Function([], [])))
```
должен вывести следующий текст:
```
def foo() {
};
```

### `Print`
Для объекта `Print` нужно вывести текст следующего вида:
```
print <expression>
```
где `<expression>` — это выражение, которое передано как параметр `expr` в конструктор объекта `Print`.

Например, следующий код:
```
pretty_print(Print(Number(42)))
```
должен вывести следующий текст:
```
print 42;
```

### `Read`
Для объекта `Read` нужно вывести текст следующего вида:
```
read <name>
```
где `<name>` — это имя, переданное как параметр `name` в конструктор объекта `Read`.

Например, следующий код:
```
pretty_print(Read('x'))
```
должен вывести следующий текст:
```
read x;
```

### `Number`
Для объекта типа `Number` нужно вывести в десятичном виде число, которое было передано в конструктор.

Например, следующий код:
```
pretty_print(Number(10))
```
должен вывести следующий текст:
```
10;
```

Точка с запятой в конце нужна, так как `pretty_print` принимает на вход команду языка и поэтому должен вывести точку с запятой после него.
Например, в контексте арифметического выражения эта точка с запятой не понадобится.

### `Reference`
Для объекта типа `Reference` необходимо вывести имя (параметр `name`), переданное в конструктор `Reference`.

Например,с ледующий код:
```
pretty_print(Reference('x'))
```
должен вывести следующий текст:
```
x;
```

Точка с запятой нужна в конце по тем же соображениям, что и в случае с `Number`.

### `BinaryOperation`.
Для объекта `BinaryOperation` нужно вывести левый операнд, который является арифметическим выражением,
оператор и затем правый операнд, который также является арифметическим выражением, с учетом приоритетов
(т.е. может потребоваться вывести дополнительные круглые скобки).

Приоритеты операций и ассоциативность приведены в таблице (как для бинарных операторов, так и для унарных).
Операции в начале таблицы имеют больший приоритет, чем операции в конце таблицы:

|Оператор|Ассоциативность|
|---|---|
|`-` (унарный минус), `!` (логическое отрицание)|справа-налево|
|`*`, `/`, `%`|слева-направо|
|`-`, `+`|слева-направо|
|`<`, `<=`, `>`, `>=`|слева-направо|
|`==`, `!=`|слева-направо|
|`&&`|слева-направо|
|`||`|слева-направо|

Например, следующий код:

```
add = BinaryOperation(Number(2), ‘+’, Number(3))
mul = BinaryOperation(Number(0), ‘*’, add)
pretty_print(mul)
```

может вывести такой текст:
```
1 * (2 + 3);
```
а может вывести такой текст:
```
((1) * ((2) + (3)));
```
Но не может вывести такой текст:
```
1 * 2 + 3;
```

Точка с запятой в конце нужна по тем же соображениям, что и для `Number`.

### `UnaryOperation`
Вывод для `UnaryOperation` в целом аналогичен выводу для `BinaryOperation`,
есть только одно замечание — используются префиксные унарные операции.

Например, следующий код:

```
pretty_print(Operation('-', Number(42)))`
```
может вывести следующий текст:
```
-42;
```
а может вывести:
```
(-(42));
```

Точка с запятой в конце нужна по тем же соображениям, что и для `Number`.

### `FunctionCall`
Для объекта `FunctionCall` нужно вывести текст следующего вида:
```
<expr>(<arg 0>, <arg 1>, …, <arg n>)
```
где:
* `<expr>` — арифметическое выражение, переданное в конструктор `FunctionCall` как аргумент `fun_expr`
* `<arg 0>`, `<arg 1>`, …, `<arg n>` — список арифметических выражений, переданные в конструктор `FunctionCall`
  как параметр `args`, все выражения разделены запятыми (лишних запятых быть не должно).
  Учтите, что `args` может быть пустым списком, в этом случае нужно вывести пустые круглые скобки.

Например, следующий код:

```
pretty_print(FunctionCall(Reference('foo'), [Number(1), Number(2), Number(3)]))
```
должен вывести следующий текст:
```
foo(1, 2, 3);
```

## Тесты
Требуется при помощи pytest:

1. Для каждого примера из условия проверить корректность вывода, используя напрямую `PrettyPrinter`.
2. Для большого end-to-end примера из условия проверить корректность вывода, используя `print_pretty`.

## Требования к корректности решения
Если присланные файлы не соответствуют хотя бы одному из условий ниже, решение считается некорректным и оценивается в 0 баллов:

* Должны отсутствовать синтаксические ошибки для Python 3
* `pycodestyle` при запуске без флагов не должен выдавать ошибок и предупреждений
* Все ваши автоматические тесты должны проходить
* `PrettyPrinter` должен наследоваться от `ASTNodeVisitor`
* В реализации `PrettyPrinter` не используется явная информацию о типах (т.е. функции `isinstance`, `type` и им подобные конструкции языка python, которые позволяют явно проверять тип объекта)
* Вывод должен содержать разумные отступы.
  Синтаксис языка этого не требует, но мы это будем проверять (т. е. тела функций и списки предложений в Condtional должны иметь больший отступ, чем окружающий их контекст)
* Для отступов используйте либо пробелы либо табуляции, но не мешайте оба символа вместе.
* Точка с запятой ставится только после предложений языка.

# Формат сдачи
TODO: как (пере)сдавать через PR
TODO: переписывание истории
* К письму прикрепите файл `model.py` с реализацией классов и файл `test_model.py` с автоматическими тестами на pytest.
* Запрещается добавлять код на верхний уровень всех файлов, за исключением объявлений процедур, функций, констант, классов и импортов.

# Сроки сдачи
|   | `18.Б09-пу` | `18.Б10-пу` |Максимальное количество баллов при сдаче в срок
|---|---|---|---|
|Дата выдачи|Среда, 06.03.2019|Среда, 06.03.2019|   |
|Мягкий дедлайн|Среда, 13.03.2019, 22:59|Среда, 13.03.2019, 22:59|5|
|Жёсткий дедлайн|Среда, 20.03.2019, 22:59|Среда, 20.03.2019, 22:59|2.5|
